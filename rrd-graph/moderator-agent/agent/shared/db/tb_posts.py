import pg8000
import sqlalchemy
from sqlalchemy import insert, select, update, and_, or_
from sqlalchemy import Table, Column, Integer, String, BigInteger, ARRAY, TIMESTAMP, Double, ForeignKey
from datetime import datetime, UTC
from enum import Enum
import pytz



class PostType(Enum):
    POST = "post"
    COMMENT = "comment"
    PAGE = "page"


class PostStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    SENTIMENTED = "sentimented"
    INGNORED = "ignored"
    GENERATED = "generated"


class Post():
    def __init__(self, engine: sqlalchemy.engine.Engine, table_name="posts"):
        self.engine = engine
        self.table = Table(
            table_name,
            sqlalchemy.MetaData(),
            Column("post_id", String, primary_key=True, comment="""
                Unique identifier each record as primary key, post_id is follow {platform abbr}-UUID format, e.g.: 
                Twitter: tw, Google Search: gs, Google News: gn, Instagram: ig, etc.
            """),
            Column("thread_id", BigInteger, ForeignKey("threads.thread_id"), nullable=False, comment="""
                Unique identifier, acts as foreign key to threads table.
            """),
            Column("platform_id", String, ForeignKey("platforms.platform_id"), nullable=False, comment="""
                Platform ID is uniqe string, act as foreign key to platforms table.
            """),
            Column("parent_id", String, ForeignKey("posts.post_id"), comment="""
                It refers to post_id as its parent post.
            """),
            Column("content", String, nullable=False, comment="""
                The content of this post, comment or page.
            """),
            Column("summary", String, comment="""
                Summery of this content.
            """),
            Column("engaged_content", String, comment="""
                The content is generated by LLM to mitigate impact of this content.
            """),
            Column("conent_type", String, nullable=False),
            Column("user_id", String),
            Column("hastags", ARRAY(String)),
            Column("likes", Integer),
            Column("shares", Integer),
            Column("comments", Integer),
            Column("sentiment_score", Double),
            Column("sentiment_magnitude", Double),
            Column("sentiment_label", String),
            Column("status", String),
            Column("created_at", TIMESTAMP),
            Column("scraped_at", TIMESTAMP, nullable=False),
            Column("sentiment_at", TIMESTAMP),
            Column("generated_at", TIMESTAMP),
            Column("updated_at", TIMESTAMP),
            comment="""
                The posts table is to store all collected POST, COMMENT and PAGE data from internet.
            """
        )


    # def __del__(self):
    #     print("__del__")
    #     try:
    #         self.connector.close()
    #     except Exception as e:
    #         print(e)


    def create_posts_in_batch(self, posts:list[dict]=None) -> list[dict]:
        r_posts=[]
        if len(posts) > 0:
            try:
                with self.engine.connect() as conn:
                    for post in posts:
                        # post["scraped_at"] = datetime.now(UTC).isoformat()
                        stmt = (
                            insert(self.table).values(post)
                        )
                        print(stmt)
                        r = conn.execute(stmt)
                        r_posts.append(post)
                    conn.commit()
            except Exception as e:
                print(f"Failed to insert POSTS with err: {e}")
                conn.rollback()
            finally:
                print("finally")
                conn.close()
                
            return  r_posts



    def create_post(self, post:dict=None)->dict:
        if bool(post):
            post["scraped_at"] = datetime.now(UTC).isoformat()
            stmt = (
                insert(self.table).values(post)
            )
            print(stmt)
            try:
                with self.engine.connect() as conn:
                    r = conn.execute(stmt)
                    conn.commit()
                    return  r.inserted_primary_key_rows[0].post_id
            except Exception as e:
                print(e)
                conn.rollback()
            finally:
                print("finally")
                conn.close()
                
            return None
        else:
            return None
    

    def recent_top100_worst_posts(self, thread_id:str) -> list[dict]:
        stmt = (
            select(self.table)
                .where(
                    and_(
                        self.table.c.thread_id == int(thread_id),
                        or_(
                            self.table.c.status == "sentimented",
                            self.table.c.status == "generated"
                        ),
                        self.table.c.sentiment_score < 0
                    )
                )
                .order_by(self.table.c.created_at.desc(), self.table.c.sentiment_score.desc())
                .limit(100)
        )
        print(stmt)
        d_posts = []
        try:
            with self.engine.connect() as conn:
                rows = conn.execute(stmt).fetchall()
                for r in rows:
                    d_posts.append(r)
        except Exception as e:
            print(e)
        finally:
            print("finally")
            conn.close()
            
        return d_posts


    def recent_top100_best_posts(self, thread_id:str) -> list[dict]:
        stmt = (
            select(self.table)
                .where(
                    and_(
                        self.table.c.thread_id == int(thread_id),
                        or_(
                            self.table.c.status == "sentimented",
                            self.table.c.status == "generated"
                        ),

                        self.table.c.sentiment_score > 0
                    )
                )
                .order_by(self.table.c.created_at.desc(), self.table.c.sentiment_score.desc())
                .limit(100)
        )
        print(stmt)
        d_posts = []
        try:
            with self.engine.connect() as conn:
                rows = conn.execute(stmt).fetchall()
                for r in rows:
                    d_posts.append(r)
        except Exception as e:
            print(e)
        finally:
            print("finally")
            conn.close()
            
        return d_posts


    def recent_top100_neutral_posts(self, thread_id:str) -> list[dict]:
        stmt = (
            select(self.table)
                .where(
                    and_(
                        self.table.c.thread_id == int(thread_id),
                        or_(
                            self.table.c.status == "sentimented",
                            self.table.c.status == "generated"
                        ),
                        self.table.c.sentiment_score > 0
                    )
                )
                .order_by(self.table.c.created_at.desc(), self.table.c.sentiment_score.desc())
                .limit(100)
        )
        print(stmt)
        d_posts = []
        try:
            with self.engine.connect() as conn:
                rows = conn.execute(stmt).fetchall()
                for r in rows:
                    d_posts.append(r)
        except Exception as e:
            print(e)
            conn.rollback()
        finally:
            print("finally")
            conn.close()
            
        return d_posts

    def sentiment_distribution_by_label(self, thread_id:str) -> dict:
        stmt = f"""
            SELECT
                thread_id,
                COUNT(CASE WHEN sentiment_label == 'positive' THEN 1 END) AS positive,
                COUNT(CASE WHEN sentiment_label == 'neutral' THEN 1 END) AS neutral,
                COUNT(CASE WHEN sentiment_label == 'negtive' THEN 1 END) AS negtive
            FROM
                posts
            WHERE
                thread_id={thread_id}
                AND status IN ('sentimented', 'generated')
            GROUP BY
                thread_id
        """
        print(stmt)
        try:
            with self.engine.connect() as conn:
                row = conn.exec_driver_sql(stmt).fetchone()
                return row._asdict()
        except Exception as e:
            print(e)
        finally:
            print("finally")
            conn.close()
            
        return None


    def sentiment_distribution_by_score(self, thread_id:str) -> dict:
        stmt = f"""
            SELECT
                thread_id,
                COUNT(CASE WHEN sentiment_score > 0 THEN 1 END) AS positive,
                COUNT(CASE WHEN sentiment_score = 0 THEN 1 END) AS neutral,
                COUNT(CASE WHEN sentiment_score < 0 THEN 1 END) AS negative
            FROM
                posts
            WHERE
                thread_id={thread_id}
                AND status IN ('sentimented', 'generated')
            GROUP BY
                thread_id
        """
        print(stmt)
        try:
            with self.engine.connect() as conn:
                row = conn.exec_driver_sql(stmt).fetchone()
                return row._asdict()
        except Exception as e:
            print(e)
        finally:
            print("finally")
            conn.close()
            
        return None


    def sentiment_distribution_by_time(self, thread_id:str, platform_id: str, start:str, end:str) -> list[dict]:
        if platform_id == "*":
            platform_cd = ""
        else:
            platform_cd = f"AND platform_id='{platform_id}'"
        stmt = f"""
            SELECT
                thread_id,
                platform_id,
                COUNT(CASE WHEN sentiment_score > 0 THEN 1 END) AS positive,
                COUNT(CASE WHEN sentiment_score = 0 THEN 1 END) AS neutral,
                COUNT(CASE WHEN sentiment_score < 0 THEN 1 END) AS negtive
            FROM
                posts
            WHERE
                thread_id={thread_id}
                {platform_cd}
                AND status IN ('sentimented', 'generated')
                AND created_at >= '{datetime.strptime(start, '%Y-%m-%d %H:%M:%S').astimezone(pytz.utc).strftime('%Y-%m-%d %H:%M:%S')}'
                AND created_at <= '{datetime.strptime(end, '%Y-%m-%d %H:%M:%S').astimezone(pytz.utc).strftime('%Y-%m-%d %H:%M:%S')}'
            GROUP BY
                thread_id, platform_id
        """
        print(stmt)
        ds_data=[]
        try:
            with self.engine.connect() as conn:
                rows = conn.exec_driver_sql(stmt).fetchall()
                for r in rows:
                    ds_data.append(r._asdict())
        except Exception as e:
            print(e)
        finally:
            print("finally")
            conn.close()
            
        return ds_data


    def latest_100_posts(self, thread_id:str) -> list[dict]:
        stmt = (
            select(self.table)
                .where(
                    and_(
                        self.table.c.thread_id == int(thread_id),
                        self.table.c.status == "pending"
                    )
                )
                .order_by(self.table.c.created_at.desc()).limit(100)
                .with_for_update()
        )
        print(stmt)
        d_posts = []
        try:
            with self.engine.connect() as conn:
                rows = conn.execute(stmt).fetchall()
                for r in rows:
                    d_posts.append(r)
                    update_stmt = (
                        update(self.table)
                            .where(
                                and_(
                                    self.table.c.post_id == r.post_id,
                                    self.table.c.thread_id == r.thread_id,
                                    self.table.c.status == "pending"
                                )
                            )
                            .values(
                                updated_at=datetime.now(UTC).isoformat(),
                                status="processing"
                            )
                    )
                    print(update_stmt)
                    conn.execute(update_stmt)
                conn.commit()
                
        except Exception as e:
            print(e)
            conn.rollback()
        finally:
            print("finally")
            conn.close()
            
        return d_posts


    def save_sentiment_results(self, sd_data: list[dict]) -> list[dict]:
        try:
            with self.engine.connect() as conn:
                for post in sd_data:
                    stmt = (
                        update(self.table).
                        where(self.table.c.post_id == post.get("post_id")).
                        values({
                            "sentiment_score": post.get("sentiment_score"),
                            "sentiment_magnitude": post.get("sentiment_magnitude"),
                            "sentiment_score": post.get("sentiment_score"),
                            "sentiment_label": post.get("sentiment_label"),
                            "status": post.get("status"),
                            "sentiment_at": post.get("sentiment_at"),
                            "updated_at": datetime.now(UTC).isoformat()
                        })
                    )
                    print(stmt)
                    r = conn.execute(stmt)
                conn.commit()
                return  sd_data
        except Exception as e:
            print(e)
            conn.rollback()
        finally:
            print("finally")
            conn.close()
            
        return None

    def semtiment_score_by(self, thread_id: str, platform_id: str, start: str, end: str) -> list[dict]:
        print(f"thread_id={thread_id}, platform_id={platform_id}, start={start}, end={end}")
        if platform_id == "*":
            print("platform_id == *")
            stmt = select(self.table).where(
                    and_(
                        self.table.c.thread_id == int(thread_id),
                        or_(
                            self.table.c.status == "sentimented",
                            self.table.c.status == "generated"
                        ),
                        self.table.c.sentiment_at > datetime.strptime(start, '%Y-%m-%d %H:%M:%S').astimezone(pytz.utc),
                        self.table.c.sentiment_at < datetime.strptime(end, '%Y-%m-%d %H:%M:%S').astimezone(pytz.utc)
                    )
                ).order_by(self.table.c.created_at)
            
        else:
            stmt = select(self.table).where(
                       and_(
                            self.table.c.thread_id == int(thread_id),
                            self.table.c.platform_id == platform_id,
                            or_(
                                self.table.c.status == "sentimented",
                                self.table.c.status == "generated"
                            ),
                            self.table.c.sentiment_at > datetime.strptime(start, '%Y-%m-%d %H:%M:%S').astimezone(pytz.utc),
                            self.table.c.sentiment_at < datetime.strptime(end, '%Y-%m-%d %H:%M:%S').astimezone(pytz.utc)
                       )
                ).order_by(self.table.c.created_at)

        print(stmt)
        d_posts = []
        try:
            with self.engine.connect() as conn:
                rows = conn.execute(stmt).fetchall()
                for r in rows:
                    d_posts.append(r._asdict())
        except Exception as e:
            print(e)
        finally:
            print("finally")
            conn.close()
            
        return d_posts

    def posts_distribution(self) -> list[dict]:
        stmt = (
            select(self.table.c.thread_id, sqlalchemy.func.count(self.table.c.post_id).label("count"))
                .group_by(self.table.c.thread_id)
        )
        print(stmt)
        d_posts = []
        try:
            with self.engine.connect() as conn:
                rows = conn.execute(stmt).fetchall()
                for r in rows:
                    d_posts.append(r._asdict())
        except Exception as e:
            print(e)
        finally:
            print("finally")
            conn.close()
            
        return d_posts       

if __name__ == "__main__":
    pt = Post()
    posts = pt.recent_top100_worst_posts("1")
    for post in posts:
        print(post)